---
title: "Data preapration"
author: "Juliano Palacios-Abrantes & Sarah M. Roberts"
date: "2022-08-19"
output: html_document
---

```{r setup, include = F}

load_pkg(c(
  # For grid estimation and species selection
  "spatialEco","tidyverse", "geosphere","raster","units","matrixStats","sf",
  # For collaborative ease
  "here"
  ))

# For grid e
# Fix new updates of sf package
sf::sf_use_s2(use_s2 = FALSE)


```


#MPA coastal and marine 
load the data into R 

```{r}
MPA1 <- read_sf(here("./Data/spatial/WDPA_WDOECM_Jul2022_Public_marine_shp/WDPA_WDOECM_Jul2022_Public_marine_shp_0/WDPA_WDOECM_Jul2022_Public_marine_shp-polygons.shp"))
#plot(MPA1)

MPA2 <- read_sf(here("./Data/spatial/WDPA_WDOECM_Jul2022_Public_marine_shp/WDPA_WDOECM_Jul2022_Public_marine_shp_1/WDPA_WDOECM_Jul2022_Public_marine_shp-polygons.shp"))

MPA3 <- read_sf(here("./Data/spatial/WDPA_WDOECM_Jul2022_Public_marine_shp/WDPA_WDOECM_Jul2022_Public_marine_shp_2/WDPA_WDOECM_Jul2022_Public_marine_shp-polygons.shp"))

MPA <- dplyr::bind_rows(list(MPA1, MPA2, MPA3))
crs <- "+init=epsg:4326"

```

#dissolve so that they are not overlapping 
This is necessary for the area calculation 
Here is where you would select out just the Marine (2 or the marine and coastal, 2 and 1)
You can also select out just the no take here. 
```{r}
MPA$to_dissolve <- "A"

MPA_dissolve <- MPA %>% group_by(to_dissolve) %>% summarize()
MPA_dissolve <- st_transform(MPA_dissolve, crs = st_crs(crs))


#ggplot() + geom_sf(data = MPA, aes(fill = NO_TAKE)) + 
  #geom_sf(data = MPA_dissolve, fill = NA, colour = "red")
```

##which gridcells overlap with an MPA (and what is the area of that gridcell that contains and MPA)

```{r}
grid <- read_sf(here("./Data/spatial/worldsq_EA.shp"))

#convert grid coordinate system to be same as lat long WGS_1984
grid <- st_transform(grid, crs = st_crs(crs))

#this tells you which gridcells intersect with an MPA and what area of the gridcell is covered 
grid_intersection <- st_intersection(grid, MPA_dissolve) %>% 
  group_by(Seq) %>% 
  summarise(geom = st_union(geometry)) %>%
  mutate(geom = st_sfc(geom),
         area = st_area(geom))

grid_intersection$status <- "protected" #lets us know that those grid cells have some level of MPA wiithin them 

#join this back to the big grid (right now we just have the gridIDs that are overlapping an MPA)
grid_intersection_2 <- as.data.frame(grid_intersection)
grid2 <- as.data.frame(grid)
grid2 <- left_join(grid2, grid_intersection_2, by = "Seq")
grid2$protected_area_m2  <- as.numeric(grid2$area)
grid2 <- grid2 %>% dplyr::select(-geom)
grid3 <- grid2
grid2 <- st_as_sf(grid2)




# ggplot() + geom_sf(subset(grid2, grid2$status == "protected"), mapping = aes(fill = protected_area_m2))+ geom_sf(grid_intersection, mapping = aes(colour = "red"))

#that looks like it worked to me. 

#we can join back to the gridPoints file for the next step 
gridpoints <- read.csv(here("./Data/Lon_Lat_DBEM.txt"), header = FALSE)
colnames(gridpoints) <- c("Seq", "long", "lat")
gridpoints <- left_join(gridpoints, grid3, by = "Seq")

# ggplot() +
#   geom_point(data = subset(gridpoints, gridpoints$status == "protected"), aes(x = Lon, y = Lat), size = .2, colour = "red") 

grid_sp <- st_as_sf(gridpoints, coords = c("long", "lat"), crs = st_crs(crs))

```

#figure out surrounding grids 
```{r}
grid_sp_MPA <- grid_sp %>% dplyr::filter(status == "protected")
st_crs(grid_sp_MPA) <- NA
grid_sp_no_MPA <- grid_sp %>% dplyr::filter(is.na(status))
st_crs(grid_sp_no_MPA) <- NA

grid_MPA <- gridpoints %>% dplyr::filter(status == "protected")
grid_no_MPA <- gridpoints %>% dplyr::filter(is.na(status))


dist <- st_distance(grid_sp_no_MPA, grid_sp_MPA) #calculate all of the distances 
colnames(dist) <- grid_sp_MPA$Seq #column names are the protected gridIDs

mins <- rowMins(dist, na.rm = T)
dist_n <- as.data.frame(mins)
dist_n$assoc_ID <- apply(dist, 1, function(x) colnames(dist)[which.min(x)]) #find which one they are closest to - need to know for proportion calc later on

dist_n$Seq <- grid_sp_no_MPA$Seq


dist_touching <- subset(dist_n, dist_n$mins < .75)
dist_touching <-left_join(dist_touching, grid_no_MPA, by = "Seq")
dist_touching <- dist_touching %>% add_count(assoc_ID) %>% mutate("prop" = (1/n) + 1)

# ggplot() +
#   geom_point(data = grid_MPA, aes(x = Lon, y = Lat), size = .2, colour = "red") + 
#   geom_point(data = dist_touching, aes(x = long, y = lat), size = .2, colour = "blue")



#ookay that seemed to work 
```
#### Clean up the dataset 

```{r}
dist_touching$status <- "surrounding"
dist_touching <- dist_touching %>% dplyr::select(-mins, -n, -assoc_ID)
grid_MPA$prop <- 0
grid_MPA$status <- "protected"

pt <- rbind(dist_touching, grid_MPA)

grid_final <- left_join(gridpoints, pt, by = c("Seq","long", "lat"))


#checkit 
ggplot() +
  geom_point(data = grid_MPA, aes(x = Lon, y = Lat), size = .2, colour = "red") + 
  geom_point(data = dist_touching, aes(x = long, y = lat), size = .2, colour = "blue") +
  geom_tile(data = grid_final, aes(x = long, y = lat, fill = status.y), size = .2, colour = "black")+ 
  coord_sf(xlim=c(-35, -30), ylim=c(40,45), expand = TRUE)

grid_final <-grid_final %>% dplyr::select(Seq, Lat.x, Lon.y, area.x, protected_area_m2.x, status.y, prop)

write.csv(grid_final, here("./Data/mpa_scenarios/grid_all_mpas.csv"))
```

